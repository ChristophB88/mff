
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Working with financial data: regression analysis</title><meta name="generator" content="MATLAB 8.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-08-21"><meta name="DC.source" content="matlab_script_2.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Working with financial data: regression analysis</h1><!--introduction--><p>Christian Groll</p><p>Chair of Financial Econometrics, Ludwig-Maximilians-University Munich.</p><p>All rights reserved.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Load historic DAX prices</a></li><li><a href="#11">Plotting financial data</a></li><li><a href="#14">Logical indexing</a></li><li><a href="#20">Exercises: logical indexing</a></li><li><a href="#26">Missing data</a></li><li><a href="#27">Object oriented programming</a></li><li><a href="#28">Exercises</a></li><li><a href="#29">Regression analysis</a></li><li><a href="#37">CAPM</a></li></ul></div><p>This is the second part of the MATLAB course. Here we will show how to download real data and how this data can be further processed.</p><p>Then, as first application, we will examine whether some theoretical relationships between risk and return can be found in german stock data. This analysis will be based on regression models.</p><p>Subsequently, we will try to find deterministic trends in stock market data based on curve fitting approaches. Only the next script will show common approaches to modelling of stock market returns as stochastic variables.</p><h2>Load historic DAX prices<a name="2"></a></h2><p>The following code provides an example of the usage of the function hist_stock_data, which is able to download historic stock prices and trading volumes based on the data provided by Yahoo!finance. In order to make the data comply with our requirements, some additional treatments are needed first.</p><pre class="codeinput"><span class="comment">% specify ticker symbol as string variable</span>
tickSym = <span class="string">'^GDAXI'</span>;     <span class="comment">% specify stock data of interest</span>

<span class="comment">% specify beginning and ending as string variables</span>
dateBeg = <span class="string">'01011990'</span>;   <span class="comment">%  day, month, year: ddmmyyyy</span>
dateEnd = <span class="string">'01072013'</span>;
</pre><p>Alternatively, dates also can be determined dynamically, with regard to today. Since the MATLAB command "today" measures time on a numeric scale, the value displayed is a number.</p><pre class="codeinput"><span class="comment">% display date of today</span>
fprintf([<span class="string">'\nToday is '</span> num2str(today) <span class="string">'.\n'</span>])
    <span class="comment">% Note: fprintf is able to display a string to the command</span>
    <span class="comment">% window, without having to assign it to a variable or MATLAB's</span>
    <span class="comment">% temporary placeholder "ans" (short for "answer") first. In</span>
    <span class="comment">% order to get the input string, in this case we first have to</span>
    <span class="comment">% concatenate smaller strings into one large string.</span>
</pre><pre class="codeoutput">
Today is 735832.
</pre><p>In order to make the numeric data value more meaningful, we can transform it with the function datestr() into a date expression. As a string, this can be directly assigned to the variable declaring the end of the data period requested.</p><pre class="codeinput"><span class="comment">% dynamic assignment to end of period</span>
dateEnd = datestr(today, <span class="string">'ddmmyyyy'</span>)  <span class="comment">% today as last date</span>
</pre><pre class="codeoutput">
dateEnd =

21082014

</pre><p>However, instead of using "today", you also can use the command "date", which returns the date as string right away.</p><pre class="codeinput">fprintf([<span class="string">'\nToday is '</span> date <span class="string">'.\n'</span>])
</pre><pre class="codeoutput">
Today is 21-Aug-2014.
</pre><p>In order to download data from Yahoo!finance, we make use of the function hist_stock_data. This function can be found at the MATLAB File Exchange at <a href="http://www.mathworks.com/matlabcentral/fileexchange/">http://www.mathworks.com/matlabcentral/fileexchange/</a>. The File Exchange is a place where users can find and share content related to MATLAB development.</p><pre class="codeinput"><span class="comment">% load data</span>
daxCrude = hist_stock_data(dateBeg, dateEnd, tickSym);
</pre><p>The function hist_stock_data returns a structure variable. A more detailed insight into the formatting of the output can be achieved with queries.</p><pre class="codeinput">daxCrude
exampleDateEntries = daxCrude.Date(1:4)
</pre><pre class="codeoutput">
daxCrude = 

      Ticker: '^GDAXI'
        Date: {6012x1 cell}
        Open: [6012x1 double]
        High: [6012x1 double]
         Low: [6012x1 double]
       Close: [6012x1 double]
      Volume: [6012x1 double]
    AdjClose: [6012x1 double]


exampleDateEntries = 

    '2014-08-20'
    '2014-08-19'
    '2014-08-18'
    '2014-08-15'

</pre><p>As the second query shows, historic prices are ordered with latest observations first. This configuration is disadvantageous for further work, since plotting of the prices would show the latest observations to the left. Moreover, instead of storing the dates as a cell array of string variables, we will achieve more flexibility if we store dates as serial dates, which is the same conversion we already encountered with the today command. In this numeric scale, each date is assigned to a uniquely specified number. As anchor point of this system, January 1st, 0000, is assigned to the value one.</p><pre class="codeinput">fprintf([<span class="string">'Number 1 is equal to the date '</span> datestr(1) <span class="string">'.\n'</span>])
</pre><pre class="codeoutput">Number 1 is equal to the date 01-Jan-0000.
</pre><p>In order to switch between dates given as strings and numeric serial dates the functions datestr and datenum can be used. Now we want to convert the date strings to serial dates.</p><pre class="codeinput">serialDates = datenum(daxCrude.Date, <span class="string">'yyyy-mm-dd'</span>);
<span class="comment">% second argument specifies input format of string dates</span>
</pre><p>In accordance with common convention prices and dates shall be arranged in increasing order, with most recent data at the end. Instead of manually encoding a for-loop, the MATLAB function flipud can be used to flip both matrices upside down. The results will be assigned to fields of a new structure variable called dax.</p><pre class="codeinput"><span class="comment">% flip most recent entries to the end</span>
dax.dates = flipud(serialDates);    <span class="comment">% initializes structure dax</span>
dax.prices = flipud(daxCrude.Close);
</pre><h2>Plotting financial data<a name="11"></a></h2><p>When plotting financial data, we usually want the x-axis to be denoted in dates instead of numeric values. This can be done with help of the command "datetick", which interprets values of the respective axis as serial dates, and converts the labels of the individual ticks into meaningful date strings.</p><p>Further adjustments to graphical representations can be achieved by manual configuration of figure sizes, as well as additional graphics in one figure window. Both concepts are applied in the following illustration.</p><pre class="codeinput">figure(<span class="string">'position'</span>,[50 50 1200 600]) <span class="comment">% create gray window, left</span>
                                    <span class="comment">% corner at latitude 50,</span>
                                    <span class="comment">% height 50, with width 1200</span>
                                    <span class="comment">% and height 600</span>

subplot(1, 2, 1);     <span class="comment">% Include two different white windows within</span>
                    <span class="comment">% the gray figure window. 1,2 denotes</span>
                    <span class="comment">% arrangement (one row, two columns of white</span>
                    <span class="comment">% windows), while the last number (1) denotes</span>
                    <span class="comment">% the currently used window.</span>

<span class="comment">% use plot command without further adjustments</span>
plot(dax.prices) <span class="comment">% since no x-values are specified, MATLAB</span>
                <span class="comment">% automatically numbers observations from 1 to</span>
                <span class="comment">% numel(dax.dates).</span>

subplot(1, 2, 2);
plot(dax.dates, dax.prices)
datetick <span class="string">'x'</span>    <span class="comment">% exact format of date labels can be chosen with</span>
                <span class="comment">% additional input, e.g. try datetick('x', 29) and</span>
                <span class="comment">% datetick('x', 10)</span>
xlabel(<span class="string">'dates'</span>)
ylabel(<span class="string">'prices'</span>)
title(<span class="string">'historic DAX values'</span>)

<span class="comment">% crop x-axis to relevant size only</span>
set(gca, <span class="string">'xLim'</span>,[dax.dates(1) dax.dates(end)])
</pre><img vspace="5" hspace="5" src="matlab_script_2_01.png" alt=""> <p>As can be seen at the command line used to crop the x-axis, though MATLAB renders the x-axis labels to date strings, it still needs references denoted in numeric values. That is, it is not possible to directly tell MATLAB to restrict the axis to 01.01.2000 to 31.12.2002 for example. Indexing with date strings is generally not possible. Hence, simple graphical modifications may become quite cumbersome. As first example, the maximum value during the period shall be highlighted with a red point. The general way to do this will be to first find the entry with the highest point in the price vector, which will be given as index value relative to the price matrix. Then, the index has to be converted into the respective index of the serial dates vector. In most cases, lengths of price and serial dates vectors will coincide, so that nothing needs to be done in this step. At last, this index is used to get the value of the serial dates vector at the respective entry.</p><h2>Logical indexing<a name="14"></a></h2><p>In order to find certain specified values in a given matrix, MATLAB usually makes use of the concept of logical indexing. In logical notation, a value of zero represents "no", while a value of "1" has to be interpreted as "yes". Hence, for example, when checking whether the entries of a matrix fulfill a given condition, MATLAB checks the condition on each entry, and returns a logical matrix of same size filled with zeros and ones.</p><pre class="codeinput"><span class="comment">% init matrix</span>
matr = [1 2 3 4 5 6]

<span class="comment">% check if entries are greater than 3</span>
greaterThan3 = matr&gt;3

<span class="comment">% matrix greaterThan3 is logical variable</span>
logicalCheck = islogical(greaterThan3)
</pre><pre class="codeoutput">
matr =

     1     2     3     4     5     6


greaterThan3 =

     0     0     0     1     1     1


logicalCheck =

     1

</pre><p>Such logical matrices created from logical or relational operations can be used to extract values of a given matrix. However, these extracted values are always returned arranged in vectors, so that information about the position in the original matrix is lost.</p><pre class="codeinput"><span class="comment">% get values greater than 3</span>
valuesGreater3 = matr(greaterThan3)
</pre><pre class="codeoutput">
valuesGreater3 =

     4     5     6

</pre><p>In order to compare numerical values, MATLAB uses relational operators.</p><pre class="codeinput"><span class="comment">% equal to</span>
equalThree = (matr == 3)   <span class="comment">% since single equal signs are already</span>
                        <span class="comment">% used for assignments, MATLAB notation</span>
                        <span class="comment">% requires two equality signs to check</span>
                        <span class="comment">% for equality</span>

<span class="comment">% less or equal</span>
lessEqualThree = (matr &lt;= 3)   <span class="comment">% greater or equal: &gt;=</span>

<span class="comment">% not equal to</span>
notEqualThree = (matr ~= 3)
</pre><pre class="codeoutput">
equalThree =

     0     0     1     0     0     0


lessEqualThree =

     1     1     1     0     0     0


notEqualThree =

     1     1     0     1     1     1

</pre><p>Matrix manipulation also can be done based on logical indexing. For example, set each value of matr below three to zero.</p><pre class="codeinput"><span class="comment">% new matrix given by</span>
matr(matr&lt;3)=0

<span class="comment">% multiply each entry greater than 4 with 10</span>
matr(matr&gt;4) = 4*matr(matr&gt;4)
</pre><pre class="codeoutput">
matr =

     0     0     3     4     5     6


matr =

     0     0     3     4    20    24

</pre><p>In order to check more than one condition, MATLAB also includes operators to combine logical matrices.</p><pre class="codeinput"><span class="comment">% create two random logicals</span>
log1 = (rand(3)&gt;0.5)
log2 = (rand(3)&gt;0.5)

<span class="comment">% elementwise AND: both logicals have to be 1</span>
AND = (log1 &amp; log2)

<span class="comment">% elementwise OR: at least one of both logicals has to be 1</span>
OR = (log1 | log2)

<span class="comment">% NOTBOTH: elementwise AND inverted with tilde command</span>
NOTBOTH = ~AND
</pre><pre class="codeoutput">
log1 =

     1     0     0
     1     0     0
     0     0     0


log2 =

     0     1     0
     0     1     0
     1     0     1


AND =

     0     0     0
     0     0     0
     0     0     0


OR =

     1     1     0
     1     1     0
     1     0     1


NOTBOTH =

     1     1     1
     1     1     1
     1     1     1

</pre><p>In order to not lose information about the position of entries within a matrix, you can use the find() function, which returns the indices of the first k entries which fulfill a certain condition. However, note that indices are given in single index notation.</p><pre class="codeinput">matr
greater20 = (matr&gt;=20) <span class="comment">% shows logical matrix: indices could be read</span>
                    <span class="comment">% off manually</span>
find(matr&gt;=20)     <span class="comment">% automatically returns all indices with logical</span>
                <span class="comment">% value one</span>
find(matr&gt;=20, 1)   <span class="comment">% returns only first index with logical value one</span>
</pre><pre class="codeoutput">
matr =

     0     0     3     4    20    24


greater20 =

     0     0     0     0     1     1


ans =

     5     6


ans =

     5

</pre><h2>Exercises: logical indexing<a name="20"></a></h2><p>In order to deepen your understanding of logical indexing, you now should test yourself at the logical indexing assignment at the coursework homepage on https://coursework.mathworks.com.</p><p>Returning to the original intention to highlight the maximum price value, this gives</p><pre class="codeinput"><span class="comment">% find index of maximum price</span>
ind = find(dax.prices == max(dax.prices), 1);

<span class="comment">% find associated serial date</span>
maxDate = dax.dates(ind);

<span class="comment">% include in subplot(1, 2, 2)</span>
subplot(1, 2, 2)
hold <span class="string">on</span>;    <span class="comment">% allows to add elements, without deleting previous</span>
            <span class="comment">% graphic</span>

plot(maxDate, max(dax.prices), <span class="string">'.r'</span>, <span class="string">'MarkerSize'</span>, 18)
shg         <span class="comment">% show current graphic: pops up figure window again</span>
hold <span class="string">off</span>;   <span class="comment">% next graphic will not be included again</span>
</pre><img vspace="5" hspace="5" src="matlab_script_2_02.png" alt=""> <p>Despite of going this quite cumbersome programmatic way, MATLAB also allows interactive request in figures. This way, press the "Data Cursor" button in the figures toolbar, select the global maximum on your own by clicking on it, then right click on datatip, and "Export Cursor Data to Workspace". Set name to maxPrice. This exports information about the maximum stock price into a structure called maxPrice.</p><p>Instead of absolute prices, investors usually are more interested in returns of the dax, where absolute gains / losses are put in relation to the capital invested. Since each return needs one starting value and one ending value, the length of the time series will decrease by one. Hence, also the date vector has to be adapted.</p><pre class="codeinput"><span class="comment">% transform prices to discrete percentage returns</span>
dax.disRet = 100*(dax.prices(2:end) - dax.prices(1:end-1))./<span class="keyword">...</span>
    dax.prices(1:end-1);

<span class="comment">% date vector for returns</span>
dax.retDates = dax.dates(2:end);

<span class="comment">% compare prices and returns in figure</span>
close   <span class="comment">% closes previously used figure window</span>

<span class="comment">% plot prices</span>
ax(1) = subplot(2, 1, 1); <span class="comment">% storage of axes handle at ax(1) allows</span>
                        <span class="comment">% accessing it later</span>
plot(dax.retDates, dax.prices(2:end))
datetick <span class="string">'x'</span>
set(gca, <span class="string">'xLim'</span>,[dax.retDates(1) dax.retDates(end)])
title(<span class="string">'historic DAX prices'</span>)
xlabel(<span class="string">'dates'</span>)
ylabel(<span class="string">'prices'</span>)

<span class="comment">% plot returns</span>
ax(2) = subplot(2, 1, 2);
plot(dax.retDates, dax.disRet)
datetick <span class="string">'x'</span>
set(gca, <span class="string">'xLim'</span>,[dax.retDates(1) dax.retDates(end)])
title(<span class="string">'historic DAX returns'</span>)
xlabel(<span class="string">'dates'</span>)
ylabel(<span class="string">'returns'</span>)

<span class="comment">% connect axes of both graphs: zooming in applies to both plots</span>
linkaxes([ax(1) ax(2)], <span class="string">'x'</span>)
</pre><img vspace="5" hspace="5" src="matlab_script_2_03.png" alt=""> <p>As can be seen, the return series exhibits phases of different volatilities. While most of the time rather small returns occur, there are also times were both positive and negative returns are persistently larger. This observation is usually refered to as volatility clusters, and is understood as a stylized fact about stock market data. However, when focussing on longer investment horizons, we usually neglect the information about the exact times of occurrence of each return, and take a look at the distribution of returns only. This is done with a histogram.</p><pre class="codeinput">close   <span class="comment">% closes previously used window</span>
hist(dax.disRet, 30)     <span class="comment">% sample size justifies 30 bins</span>
</pre><img vspace="5" hspace="5" src="matlab_script_2_04.png" alt=""> <p>In this figure, we want to include a line indicating the mean return over the observed period, as well as two lines indicating regions with more than two standard deviations away from the mean.</p><pre class="codeinput"><span class="comment">% calculate mean return</span>
meanRet = sum(dax.disRet)/numel(dax.disRet);

<span class="comment">% calculate standard deviation</span>
stdDev = sum((dax.disRet-meanRet).^2)/(numel(dax.disRet)-1);
stdDev = sqrt(stdDev);

<span class="comment">% check results with existing MATLAB functions</span>
deviations = [(meanRet - mean(dax.disRet))<span class="keyword">...</span>
    (stdDev-sqrt(var(dax.disRet)))]

<span class="comment">% include in graphic</span>
yLimits = get(gca, <span class="string">'yLim'</span>);
line(meanRet*[1 1], yLimits, <span class="string">'Color'</span>, <span class="string">'r'</span>)
line((meanRet+2*stdDev)*[1 1], yLimits, <span class="string">'Color'</span>, <span class="string">'r'</span>)
line((meanRet-2*stdDev)*[1 1], yLimits, <span class="string">'Color'</span>, <span class="string">'r'</span>)
text(meanRet+2*stdDev, yLimits(end)/2, <span class="string">'2 standard deviations'</span>)
</pre><pre class="codeoutput">
deviations =

     0     0

</pre><img vspace="5" hspace="5" src="matlab_script_2_05.png" alt=""> <h2>Missing data<a name="26"></a></h2><p>Downloading a single asset only with hist_stock_data will not give us any missing values in our time series, since dates without observations are simply left out. However, leaving the case of a single asset only and switching to multiple assets, the individual time series will most likely have different missing dates. For example, US stocks and German stocks have different holidays.</p><p>One way to deal with this fact would be to simply erase all dates where we do not have observations for all assets. This way, however, we will eliminate quite many observations that we could have used for univariate modeling. Hence, we will follow a more sophisticated approach, where we will keep all dates that occur in at least one stock price series, and fill the respective missing values with MATLAB's NaN. Hence, we now first want to get familiar with the behaviour of NaNs through some examples.</p><pre class="codeinput"><span class="comment">% NaNs in comparisons:</span>

NaN == NaN <span class="comment">% false</span>

NaN ~= NaN <span class="comment">% true</span>

a = [1; NaN; 3];
b = [1; NaN; 3];
a == b <span class="comment">% false</span>

NaN &gt; NaN <span class="comment">% false</span>

<span class="comment">% NaNs in mathematical operators:</span>

3 + NaN <span class="comment">% NaN</span>

mean(a) <span class="comment">% NaN</span>


<span class="comment">% NaNs in logical operators:</span>
<span class="comment">% throwing errors</span>
<span class="keyword">try</span>
    true &amp; NaN
<span class="keyword">catch</span> err
    err.message
<span class="keyword">end</span>

<span class="keyword">try</span>
    false | NaN
<span class="keyword">catch</span> err
    err.message
<span class="keyword">end</span>
</pre><pre class="codeoutput">
ans =

     0


ans =

     1


ans =

     1
     0
     1


ans =

     0


ans =

   NaN


ans =

   NaN


ans =

NaN's cannot be converted to logicals.


ans =

NaN's cannot be converted to logicals.

</pre><h2>Object oriented programming<a name="27"></a></h2><p>What we really want now is to create a function that downloads stock price data of multiple assets through hist_stock_data, combines all stocks, keeps a single dates vector including all dates that occur in at least one stock and fills missing observations with NaN. Still, however, we need to decide about the exact data type that should be used as a data container, and there are several possible types in MATLAB: cell array, structure, matrix plus dates vector, table, time series object, financial time series object, ...</p><p>Different kinds of data also exhibit different patterns. For example, time series data always comes with a time value. In addition, time values are chronologically sorted for stock prices and contain numeric values only.</p><p>Depending on the patterns of the data, we might want some basic functions to behave differently. For example, plots of time series data should have the x axis labelled by dates instead of numbers. Ideally, the plotting function for time series data and matrix data should have the same name, as we would end up with function names like 'plotTimeSeries' otherwise.</p><p>This can be achieved through object oriented programming. In addition to the data itself, the data also gets a label that tells the computer about the structure that the data represents. For example, a nx2 matrix of numeric values could in reality be representing time series data: the first column are dates in MATLAB's serial date format, while the second column represents the data. As the data still is just a matrix of numeric values, there is no way how MATLAB could distinguish between general numeric matrices and time series data.</p><p>Through object oriented programming, however, the numeric time series data could be labelled as such, so that MATLAB can find some meaning in the data in order to chose an adequate way of plotting it. Labelling the data is achieved through making it an object: the data simply gets stored as an object of a certain type.</p><p>In MATLAB, there basically exist two data types that allow such a labelling of time series data. However, depending on which type / label you assign to your data, MATLAB will interpret some basic functions differently.</p><p>Financial Time Series Objects: - requires Financial Toolbox - allows indexing with dates</p><p>Time Series Objects: - implemented aggregation functions: daily to monthy, yearly, ...</p><p>These objects usually store data in some field .Data.</p><p>Alternatively, one could also store time series data in the most general type as table. This way, however, functions can not be customized to time series patterns, and data is not restricted to numeric values only. Still, we can make use of some nice and general data manipulation functions that are implemented for tables, one of them being an outer join which we need to combine the individual assets. Hence, we will keep data stored as tables here, although the decision of the right data type basically is a matter of personal preferences. Dealing with tables, however, one still needs to decide whether time information should be stored as separate column, or as names of the rows.</p><h2>Exercises<a name="28"></a></h2><p>1.) do the table exercises at courseworks</p><p>2.) implement a function getData that downloads and processes data and returns the result as table</p><h2>Regression analysis<a name="29"></a></h2><p>One of the most important models also in econometrics is the linear model. Hence, the following lines show the implementation and estimation of a linear regression model in MATLAB. First, we sample from a specified linear model.</p><pre class="codeinput"><span class="comment">% init params</span>
nSim = 1000;       <span class="comment">% sample size</span>
muX = 12;       <span class="comment">% params explanatory variable</span>
sigmaX = 2.3;
coeff = 0.8;    <span class="comment">% regression coefficient</span>
intcept = 4.3;  <span class="comment">% regression intercept</span>

<span class="comment">% simulate explanatory variable</span>
xMatr = normrnd(muX, sigmaX, nSim, 1);

<span class="comment">% simulate standard normally distributed innovations</span>
epsilon = randn(nSim, 1);

<span class="comment">% calculate Y according to linear model</span>
yMatr = intcept + coeff*xMatr + epsilon;    <span class="comment">% do not use for loop</span>
</pre><p>Now we want to estimate the parameters of the model based on the values simulated.</p><pre class="codeinput"><span class="comment">% because of intercept, expand matrix of explanatory variables</span>
xMatr = [ones(nSim, 1) xMatr];

<span class="comment">% OLS estimation, naive way</span>
paramsHat = inv(xMatr'*xMatr)*xMatr'*yMatr;
<span class="comment">% usual estimation formula</span>

<span class="comment">% avoiding single matrix inversion as mlint warning suggests</span>
paramsHat2 = (xMatr'*xMatr)\(xMatr'*yMatr);      <span class="comment">% faster way</span>
paramsHat3 = xMatr\yMatr;                <span class="comment">% best way</span>

<span class="comment">% calculate regression line</span>
xLimits = [floor(min(xMatr(:, 2))) ceil(max(xMatr(:, 2)))];
                                 <span class="comment">% use nearest</span>
                                 <span class="comment">% neighbouring integer numbers</span>
grid = xLimits(1):0.1:xLimits(2);
vals = paramsHat(1)+paramsHat(2)*grid;

<span class="comment">% plotting data</span>
close
scatter(xMatr(:, 2), yMatr, <span class="string">'.'</span>);   <span class="comment">% used for visualizing points</span>
                                    <span class="comment">% cloud</span>

<span class="comment">% include regression line</span>
hold <span class="string">on</span>;    <span class="comment">% plot in same figure</span>
plot(grid, vals, <span class="string">'LineWidth'</span>, 2, <span class="string">'Color'</span>, <span class="string">'r'</span>)   <span class="comment">% larger line width</span>
set(gca, <span class="string">'xLim'</span>, xLimits)
xlabel(<span class="string">'regressor variable'</span>)
ylabel(<span class="string">'dependent variable'</span>)
title([<span class="string">'Linear model: estimated beta is '</span> num2str(paramsHat(2))])

hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="matlab_script_2_06.png" alt=""> <p>Because of the risk-aversion of investors, theoretical models often conclude that riskier assets should in general coincide with higher expected returns, since investors demand higher compensation for the risk involved. As a first application of the linear model, we want to investigate whether this positive relationship can be verified for German stock data. Therefore, we will download historical data of all 30 components of the German stock market index DAX, estimate their mean return and return standard deviation, and regress the mean returns on the standard deviations. Note that standard deviation is only one way to measure inherent risk, and one common criticism is that the symmetrical nature of standard deviation measures positive deviations the same way as negative ones.</p><pre class="codeinput"><span class="comment">% specify start and end point of investigation period</span>
dateBeg = <span class="string">'01011990'</span>;
dateEnd = <span class="string">'01072011'</span>;

<span class="comment">% download data of all components: dax_comp is structure array</span>
daxComp = {<span class="string">'ADS.DE'</span>, <span class="string">'ALV.DE'</span>,<span class="keyword">...</span>
    <span class="string">'BAS.DE'</span>, <span class="string">'BAYN.DE'</span>, <span class="string">'BEI.DE'</span>, <span class="string">'BMW.DE'</span>, <span class="string">'CBK.DE'</span>, <span class="string">'DAI.DE'</span>, <span class="keyword">...</span>
    <span class="string">'DB1.DE'</span>,<span class="keyword">...</span>
    <span class="string">'DBK.DE'</span>, <span class="string">'DPW.DE'</span>, <span class="string">'DTE.DE'</span>, <span class="string">'EOAN.DE'</span>, <span class="string">'FME.DE'</span>, <span class="string">'FRE.DE'</span>,<span class="keyword">...</span>
    <span class="string">'HEI.DE'</span>, <span class="string">'HEN3.DE'</span>, <span class="string">'IFX.DE'</span>, <span class="string">'LHA.DE'</span>, <span class="string">'LIN.DE'</span>, <span class="string">'MAN.DE'</span>,<span class="keyword">...</span>
    <span class="string">'MEO.DE'</span>, <span class="string">'MRK.DE'</span>, <span class="string">'MUV2.DE'</span>, <span class="string">'RWE.DE'</span>, <span class="string">'SAP'</span>, <span class="string">'SDF.DE'</span>,<span class="keyword">...</span>
    <span class="string">'SIE.DE'</span>, <span class="string">'TKA.DE'</span>, <span class="string">'VOW3.DE'</span>, <span class="string">'^GDAXI'</span>};
</pre><p>In order to conduct this analysis, we will first use our implemented function getPrices to download prices of all DAX components. Afterwards, we need to translate the prices into logarithmic returns.</p><pre class="codeinput">daxCompPrices = getPrices(dateBeg, dateEnd, daxComp);
daxCompRets = price2retWithHolidays(daxCompPrices);
</pre><p>Now that we have downloaded the data, we want to visually check them for inconsistencies. Therefore, it is best to look at normalized prices: we artificially make the starting price for all assets the same. This in general could easily be done with function cumsum. However, due to the missing observations in our data sample we need to take a different function in order to not return NaNs. Here, we use function nancumsum from the MATLAB file exchange.</p><pre class="codeinput">close   <span class="comment">% close last figure</span>
normalizedPrices = nancumsum(daxCompRets{:,:});
plot(numDates(daxCompRets), normalizedPrices)
datetick <span class="string">'x'</span>
</pre><img vspace="5" hspace="5" src="matlab_script_2_07.png" alt=""> <p>Next, we will calculate the number of observations for each stock. This way, we can see whether individual stocks have substantially less data than the rest.</p><pre class="codeinput">nObs = sum(~ismissing(daxCompRets), 1);
nObsTable = array2table(nObs);
nObsTable.Properties.VariableNames = daxCompRets.Properties.VariableNames;
</pre><p>Now that historical returns are given suitable form, we can estimate expected returns and standard deviations. Note that most statistical functions act columnwise. Hence it is always preferable to store observations of a given variable in a column vector, and use different columns for different variables. In our case, however, there are NaNs in our columns, which will lead to NaNs for any calculations as well. Hence, we need to take the missing values into account at each step. For simple statistics like mean and variance we can take the respective function from the statistics toolbox (nanmean, nanstd, ...).</p><pre class="codeinput"><span class="comment">% estimate returns and sigmas of DAX components</span>
expRets = nanmean(daxCompRets{:,:}*100);
sigmaHats = nanstd(daxCompRets{:,:}*100);

<span class="comment">% show in figure, standard deviations on x-axis</span>
close   <span class="comment">% close last figure</span>
scatter(sigmaHats, expRets, <span class="string">'.'</span>)

<span class="comment">% highlight DAX itself</span>
hold <span class="string">on</span>;
scatter(sigmaHats(end), expRets(end), 30, [1 0 0], <span class="string">'filled'</span>)

<span class="comment">% estimate regression line</span>
<span class="comment">% betaHat = [ones(numel(sigmaHats), 1) sigmaHats']\expRets';</span>
betaHat = [sigmaHats']\expRets';

<span class="comment">% calculate regression line</span>
xLimits = get(gca, <span class="string">'XLim'</span>);
grid = linspace(xLimits(1), xLimits(end), 200);   <span class="comment">% divide</span>
                                    <span class="comment">% specified interval in 200</span>
                                    <span class="comment">% parts of equal size</span>
yVals = [grid']*betaHat;

<span class="comment">% include regression line in red</span>
plot(grid, yVals, <span class="string">'r'</span>)

<span class="comment">% get R^2 from existing MATLAB function</span>
stats = regstats(expRets, sigmaHats',<span class="keyword">...</span>
    <span class="string">'linear'</span>, <span class="string">'rsquare'</span>);
title([<span class="string">'R-square of regression: '</span> num2str(stats.rsquare)])
xlabel(<span class="string">'estimated standard deviations'</span>)
ylabel(<span class="string">'estimated mean returns'</span>)
</pre><img vspace="5" hspace="5" src="matlab_script_2_08.png" alt=""> <p>Although the regression line exhibits an increasing slope as theory suggests, the R-squared of the regression is rather small. Evidence for a positive relation between return and risk is rather weak.</p><h2>CAPM<a name="37"></a></h2><p>The capital asset pricing model tries to explain asset pricies. It is set up on the assumption, that investors only get compensated for that part of an asset's risk that can not get diversified away in a portfolio. Shortly speaking, each assets partly exhibits comovements with the market, called systematic risk. Since this risk component underlies each asset, it can not be diversified away. Hence, investors need to be compensated for it. In contrast to that, the remaining risk inherent in an asset is called the idiosyncratic risk. This component is stock specific, and hence not correlated with idiosyncratic components of other firms. Hence, in a large portfolio of assets, this component could be diversified away.</p><p>In order to measure each assets' comovement with the market, we perform a linear regression of the daily returns on daily returns of a market index. Note that the theory is based on dependence to a market portfolio, where our market index here is only an imperfect substitution.</p><pre class="codeinput"><span class="comment">% preallocate vector for estimated betas</span>
nDaxComponents = size(daxCompRets, 2) -1;
betas = zeros(1, nDaxComponents);
<span class="keyword">for</span> ii=1:nDaxComponents
    betas(ii) = regress(daxCompRets{:, end},<span class="keyword">...</span>
        daxCompRets{:, ii});   <span class="comment">% no intercept involved</span>
<span class="keyword">end</span>

<span class="comment">% plot betas with expected returns</span>
close
scatter(betas, expRets(1:end-1), <span class="string">'.'</span>)

<span class="comment">% estimate regression coefficients with intercept</span>
betaHat = [ones(numel(betas), 1) betas']\expRets(1:end-1)';

<span class="comment">% include regression line</span>
xLimits = get(gca, <span class="string">'XLim'</span>);
grid = linspace(xLimits(1), xLimits(end), 200);
yVals = [ones(numel(grid), 1) grid']*betaHat;

hold <span class="string">on</span>;
plot(grid, yVals, <span class="string">'r'</span>)
xlabel(<span class="string">'estimated beta coefficients'</span>)
ylabel(<span class="string">'estimated mean returns'</span>)
title(<span class="string">'CAPM disproved?'</span>)
</pre><img vspace="5" hspace="5" src="matlab_script_2_09.png" alt=""> <p>Note that this analysis is only a very rough investigation of the validity of the CAPM, with many sources of error involved (only substitute for market portfolio, applied to returns instead of excess returns,...). In fact, the purpose merely was to come up with some easy example of regression analysis in finance. So do not make the mistake to interpret the investigations as scientifically rigurous and adequate approach. As part of a more thorough investigation at least also returns of larger time horizons would have to be examined.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Working with financial data: regression analysis
% Christian Groll
%
% Chair of Financial Econometrics, Ludwig-Maximilians-University 
% Munich.  
%
% All rights reserved.

%%
% This is the second part of the MATLAB course. Here we will
% show how to download real data and how this data can be further
% processed.
%
% Then, as first application, we will examine whether some
% theoretical relationships between risk and return can be found
% in german stock data. This analysis will be based on regression
% models.
%
% Subsequently, we will try to find deterministic trends in stock
% market data based on curve fitting approaches.
% Only the next script will show common approaches to
% modelling of stock market returns as stochastic variables.


%% Load historic DAX prices
% The following code provides an example of the usage of the
% function hist_stock_data, which is able to download historic
% stock prices and trading volumes based on the data provided by
% Yahoo!finance. In order to make the data comply with our
% requirements, some additional treatments are needed first.

% specify ticker symbol as string variable
tickSym = '^GDAXI';     % specify stock data of interest

% specify beginning and ending as string variables
dateBeg = '01011990';   %  day, month, year: ddmmyyyy
dateEnd = '01072013';

%% 
% Alternatively, dates also can be determined dynamically,
% with regard to today. Since the MATLAB command "today" measures
% time on a numeric scale, the value displayed is a number.

% display date of today
fprintf(['\nToday is ' num2str(today) '.\n'])
    % Note: fprintf is able to display a string to the command
    % window, without having to assign it to a variable or MATLAB's
    % temporary placeholder "ans" (short for "answer") first. In
    % order to get the input string, in this case we first have to
    % concatenate smaller strings into one large string.

%%
% In order to make the numeric data value more meaningful, we can
% transform it with the function datestr() into a date
% expression. As a string, this can be directly assigned to the
% variable declaring the end of the data period requested.

% dynamic assignment to end of period
dateEnd = datestr(today, 'ddmmyyyy')  % today as last date

%% 
% However, instead of using "today", you also can use the command
% "date", which returns the date as string right away.

fprintf(['\nToday is ' date '.\n'])

%%
% In order to download data from Yahoo!finance, we make use of
% the function hist_stock_data. This function can be found at the
% MATLAB File Exchange at 
% http://www.mathworks.com/matlabcentral/fileexchange/. 
% The File Exchange is a place where users can find and share
% content related to MATLAB development.

% load data
daxCrude = hist_stock_data(dateBeg, dateEnd, tickSym);

%%
% The function hist_stock_data returns a structure variable. A
% more detailed insight into the formatting of the output can be
% achieved with queries.

daxCrude
exampleDateEntries = daxCrude.Date(1:4)

%%
% As the second query shows, historic prices are ordered with latest
% observations first. This configuration is disadvantageous for
% further work, since plotting of the prices would show the latest
% observations to the left. Moreover, instead of storing the dates as
% a cell array of string variables, we will achieve more flexibility
% if we store dates as serial dates, which is the same conversion we
% already encountered with the today command. In this numeric scale,
% each date is assigned to a uniquely specified number. As anchor
% point of this system, January 1st, 0000, is assigned to the value
% one.

fprintf(['Number 1 is equal to the date ' datestr(1) '.\n'])

%%
% In order to switch between dates given as strings and numeric
% serial dates the functions datestr and datenum can be used. Now we
% want to convert the date strings to serial dates.

serialDates = datenum(daxCrude.Date, 'yyyy-mm-dd');
% second argument specifies input format of string dates

%%
% In accordance with common convention prices and dates shall be
% arranged in increasing order, with most recent data at the end.
% Instead of manually encoding a for-loop, the MATLAB function
% flipud can be used to flip both matrices upside down. The
% results will be assigned to fields of a new structure variable 
% called dax.

% flip most recent entries to the end
dax.dates = flipud(serialDates);    % initializes structure dax
dax.prices = flipud(daxCrude.Close);

%% Plotting financial data
% When plotting financial data, we usually want the x-axis to be
% denoted in dates instead of numeric values. This can be done
% with help of the command "datetick", which interprets values of 
% the respective axis as serial dates, and converts the labels of
% the individual ticks into meaningful date strings. 

%%
% Further adjustments to graphical representations can be
% achieved by manual configuration of figure sizes, as well as
% additional graphics in one figure window. Both concepts are
% applied in the following illustration.

figure('position',[50 50 1200 600]) % create gray window, left 
                                    % corner at latitude 50,
                                    % height 50, with width 1200
                                    % and height 600

subplot(1, 2, 1);     % Include two different white windows within 
                    % the gray figure window. 1,2 denotes
                    % arrangement (one row, two columns of white
                    % windows), while the last number (1) denotes 
                    % the currently used window.
               
% use plot command without further adjustments                    
plot(dax.prices) % since no x-values are specified, MATLAB 
                % automatically numbers observations from 1 to 
                % numel(dax.dates).
                
subplot(1, 2, 2);
plot(dax.dates, dax.prices)
datetick 'x'    % exact format of date labels can be chosen with 
                % additional input, e.g. try datetick('x', 29) and
                % datetick('x', 10)
xlabel('dates')
ylabel('prices')
title('historic DAX values')

% crop x-axis to relevant size only
set(gca, 'xLim',[dax.dates(1) dax.dates(end)])

%%
% As can be seen at the command line used to crop the x-axis, 
% though MATLAB renders the x-axis labels to date strings, it 
% still needs references denoted in numeric values. That is, it 
% is not possible to directly tell MATLAB to restrict the axis to
% 01.01.2000 to 31.12.2002 for example. Indexing with date
% strings is generally not possible. Hence, simple graphical
% modifications may become quite cumbersome. 
% As first example, the maximum value during the period shall be
% highlighted with a red point. The general way to do this will
% be to first find the entry with the highest point in the price
% vector, which will be given as index value relative to the
% price matrix. Then, the index has to be converted into the
% respective index of the serial dates vector. In most cases,
% lengths of price and serial dates vectors will coincide, so
% that nothing needs to be done in this step. At last, this index
% is used to get the value of the serial dates vector at the
% respective entry.

%% Logical indexing
% In order to find certain specified values in a given matrix,
% MATLAB usually makes use of the concept of logical indexing. In
% logical notation, a value of zero represents "no", while a
% value of "1" has to be interpreted as "yes". Hence, for example,
% when checking whether the entries of a matrix fulfill a given
% condition, MATLAB checks the condition on each entry, and
% returns a logical matrix of same size filled with zeros and 
% ones.

% init matrix
matr = [1 2 3 4 5 6]

% check if entries are greater than 3
greaterThan3 = matr>3

% matrix greaterThan3 is logical variable
logicalCheck = islogical(greaterThan3)

%% 
% Such logical matrices created from logical or relational 
% operations can be used to extract values of a given matrix.
% However, these extracted values are always returned arranged in
% vectors, so that information about the position in the original
% matrix is lost.

% get values greater than 3
valuesGreater3 = matr(greaterThan3)

%%
% In order to compare numerical values, MATLAB uses relational
% operators.

% equal to
equalThree = (matr == 3)   % since single equal signs are already 
                        % used for assignments, MATLAB notation
                        % requires two equality signs to check
                        % for equality

% less or equal
lessEqualThree = (matr <= 3)   % greater or equal: >=

% not equal to
notEqualThree = (matr ~= 3)

%%
% Matrix manipulation also can be done based on logical indexing.
% For example, set each value of matr below three to zero.

% new matrix given by
matr(matr<3)=0

% multiply each entry greater than 4 with 10
matr(matr>4) = 4*matr(matr>4)

%% 
% In order to check more than one condition, MATLAB also includes
% operators to combine logical matrices.

% create two random logicals
log1 = (rand(3)>0.5)
log2 = (rand(3)>0.5)

% elementwise AND: both logicals have to be 1
AND = (log1 & log2)

% elementwise OR: at least one of both logicals has to be 1
OR = (log1 | log2)

% NOTBOTH: elementwise AND inverted with tilde command
NOTBOTH = ~AND

%% 
% In order to not lose information about the position of entries
% within a matrix, you can use the find() function, which returns
% the indices of the first k entries which fulfill a certain
% condition. However, note that indices are given in single
% index notation.

matr
greater20 = (matr>=20) % shows logical matrix: indices could be read 
                    % off manually
find(matr>=20)     % automatically returns all indices with logical 
                % value one
find(matr>=20, 1)   % returns only first index with logical value one

%% Exercises: logical indexing
% In order to deepen your understanding of logical indexing, you now
% should test yourself at the logical indexing assignment at the
% coursework homepage on https://coursework.mathworks.com.

%%
% Returning to the original intention to highlight the maximum
% price value, this gives

% find index of maximum price
ind = find(dax.prices == max(dax.prices), 1);

% find associated serial date
maxDate = dax.dates(ind);

% include in subplot(1, 2, 2)
subplot(1, 2, 2)
hold on;    % allows to add elements, without deleting previous 
            % graphic

plot(maxDate, max(dax.prices), '.r', 'MarkerSize', 18)
shg         % show current graphic: pops up figure window again
hold off;   % next graphic will not be included again

%%
% Despite of going this quite cumbersome programmatic way, MATLAB
% also allows interactive request in figures. This way, press the
% "Data Cursor" button in the figures toolbar, select the global
% maximum on your own by clicking on it, then right click on
% datatip, and "Export Cursor Data to Workspace". Set name
% to maxPrice. This exports information about the maximum stock 
% price into a structure called maxPrice.


%%
% Instead of absolute prices, investors usually are more
% interested in returns of the dax, where absolute gains / losses
% are put in relation to the capital invested. Since each return
% needs one starting value and one ending value, the length of
% the time series will decrease by one. Hence, also the date
% vector has to be adapted.

% transform prices to discrete percentage returns
dax.disRet = 100*(dax.prices(2:end) - dax.prices(1:end-1))./...
    dax.prices(1:end-1);

% date vector for returns
dax.retDates = dax.dates(2:end);

% compare prices and returns in figure
close   % closes previously used figure window

% plot prices
ax(1) = subplot(2, 1, 1); % storage of axes handle at ax(1) allows 
                        % accessing it later 
plot(dax.retDates, dax.prices(2:end))   
datetick 'x'
set(gca, 'xLim',[dax.retDates(1) dax.retDates(end)])
title('historic DAX prices')
xlabel('dates')
ylabel('prices')

% plot returns
ax(2) = subplot(2, 1, 2);
plot(dax.retDates, dax.disRet)
datetick 'x'
set(gca, 'xLim',[dax.retDates(1) dax.retDates(end)])
title('historic DAX returns')
xlabel('dates')
ylabel('returns')

% connect axes of both graphs: zooming in applies to both plots
linkaxes([ax(1) ax(2)], 'x')

%%
% As can be seen, the return series exhibits phases of different
% volatilities. While most of the time rather small returns
% occur, there are also times were both positive and negative
% returns are persistently larger. This observation is usually
% refered to as volatility clusters, and is understood as a
% stylized fact about stock market data. However, when focussing
% on longer investment horizons, we usually neglect the
% information about the exact times of occurrence of each return,
% and take a look at the distribution of returns only. This is
% done with a histogram.

close   % closes previously used window
hist(dax.disRet, 30)     % sample size justifies 30 bins

%% 
% In this figure, we want to include a line indicating the mean
% return over the observed period, as well as two lines
% indicating regions with more than two standard deviations away 
% from the mean.

% calculate mean return
meanRet = sum(dax.disRet)/numel(dax.disRet);

% calculate standard deviation
stdDev = sum((dax.disRet-meanRet).^2)/(numel(dax.disRet)-1);
stdDev = sqrt(stdDev);

% check results with existing MATLAB functions
deviations = [(meanRet - mean(dax.disRet))...
    (stdDev-sqrt(var(dax.disRet)))]

% include in graphic
yLimits = get(gca, 'yLim');
line(meanRet*[1 1], yLimits, 'Color', 'r')
line((meanRet+2*stdDev)*[1 1], yLimits, 'Color', 'r')
line((meanRet-2*stdDev)*[1 1], yLimits, 'Color', 'r')
text(meanRet+2*stdDev, yLimits(end)/2, '2 standard deviations')

%% Missing data
% Downloading a single asset only with hist_stock_data will not give us any
% missing values in our time series, since dates without observations are
% simply left out. However, leaving the case of a single asset only and
% switching to multiple assets, the individual time series will most likely
% have different missing dates. For example, US stocks and German stocks
% have different holidays.
%
% One way to deal with this fact would be to simply erase all dates where
% we do not have observations for all assets. This way, however, we will
% eliminate quite many observations that we could have used for univariate
% modeling. Hence, we will follow a more sophisticated approach, where we
% will keep all dates that occur in at least one stock price series, and
% fill the respective missing values with MATLAB's NaN. Hence, we now first
% want to get familiar with the behaviour of NaNs through some examples.

% NaNs in comparisons:

NaN == NaN % false

NaN ~= NaN % true

a = [1; NaN; 3];
b = [1; NaN; 3];
a == b % false

NaN > NaN % false

% NaNs in mathematical operators:

3 + NaN % NaN

mean(a) % NaN


% NaNs in logical operators:
% throwing errors
try
    true & NaN
catch err
    err.message
end

try 
    false | NaN
catch err
    err.message
end



%% Object oriented programming
% What we really want now is to create a function that downloads stock
% price data of multiple assets through hist_stock_data, combines all
% stocks, keeps a single dates vector including all dates that occur in at
% least one stock and fills missing observations with NaN. Still, however,
% we need to decide about the exact data type that should be used as a data
% container, and there are several possible types in MATLAB: cell array,
% structure, matrix plus dates vector, table, time series object, financial
% time series object, ...
%
% Different kinds of data also exhibit different patterns. For example,
% time series data always comes with a time value. In addition, time values
% are chronologically sorted for stock prices and contain numeric values
% only. 
% 
% Depending on the patterns of the data, we might want some basic functions
% to behave differently. For example, plots of time series data should have
% the x axis labelled by dates instead of numbers. Ideally, the plotting
% function for time series data and matrix data should have the same name,
% as we would end up with function names like 'plotTimeSeries' otherwise.
%
% This can be achieved through object oriented programming. In addition to
% the data itself, the data also gets a label that tells the computer about
% the structure that the data represents. For example, a nx2 matrix of
% numeric values could in reality be representing time series data: the
% first column are dates in MATLAB's serial date format, while the second
% column represents the data. As the data still is just a matrix of numeric
% values, there is no way how MATLAB could distinguish between general
% numeric matrices and time series data. 
% 
% Through object oriented programming, however, the numeric time series
% data could be labelled as such, so that MATLAB can find some meaning in
% the data in order to chose an adequate way of plotting it. Labelling the
% data is achieved through making it an object: the data simply gets stored
% as an object of a certain type. 
%
% In MATLAB, there basically exist two data types that allow such a
% labelling of time series data. However, depending on which type / label
% you assign to your data, MATLAB will interpret some basic functions
% differently.
%
% Financial Time Series Objects:
% - requires Financial Toolbox
% - allows indexing with dates
%
% Time Series Objects:
% - implemented aggregation functions: daily to monthy, yearly, ...
%
% These objects usually store data in some field .Data.
%
% Alternatively, one could also store time series data in the most general
% type as table. This way, however, functions can not be customized to time
% series patterns, and data is not restricted to numeric values only.
% Still, we can make use of some nice and general data manipulation
% functions that are implemented for tables, one of them being an outer
% join which we need to combine the individual assets. Hence, we will keep
% data stored as tables here, although the decision of the right data type
% basically is a matter of personal preferences. Dealing with tables,
% however, one still needs to decide whether time information should be
% stored as separate column, or as names of the rows.
 

%% Exercises
% 1.) do the table exercises at courseworks
%
% 2.) implement a function getData that downloads and processes data and
% returns the result as table

%% Regression analysis
% One of the most important models also in econometrics is the
% linear model. Hence, the following lines show the
% implementation and estimation of a linear regression model in
% MATLAB. First, we sample from a specified linear model.

% init params
nSim = 1000;       % sample size
muX = 12;       % params explanatory variable
sigmaX = 2.3;
coeff = 0.8;    % regression coefficient
intcept = 4.3;  % regression intercept

% simulate explanatory variable
xMatr = normrnd(muX, sigmaX, nSim, 1);

% simulate standard normally distributed innovations
epsilon = randn(nSim, 1);

% calculate Y according to linear model
yMatr = intcept + coeff*xMatr + epsilon;    % do not use for loop

%%
% Now we want to estimate the parameters of the model based on
% the values simulated. 

% because of intercept, expand matrix of explanatory variables
xMatr = [ones(nSim, 1) xMatr];

% OLS estimation, naive way
paramsHat = inv(xMatr'*xMatr)*xMatr'*yMatr;    
% usual estimation formula 

% avoiding single matrix inversion as mlint warning suggests
paramsHat2 = (xMatr'*xMatr)\(xMatr'*yMatr);      % faster way
paramsHat3 = xMatr\yMatr;                % best way

% calculate regression line
xLimits = [floor(min(xMatr(:, 2))) ceil(max(xMatr(:, 2)))];   
                                 % use nearest
                                 % neighbouring integer numbers
grid = xLimits(1):0.1:xLimits(2);       
vals = paramsHat(1)+paramsHat(2)*grid;    

% plotting data
close
scatter(xMatr(:, 2), yMatr, '.');   % used for visualizing points 
                                    % cloud 

% include regression line
hold on;    % plot in same figure
plot(grid, vals, 'LineWidth', 2, 'Color', 'r')   % larger line width
set(gca, 'xLim', xLimits)
xlabel('regressor variable')
ylabel('dependent variable')
title(['Linear model: estimated beta is ' num2str(paramsHat(2))])

hold off;

%%
% Because of the risk-aversion of investors, theoretical models
% often conclude that riskier assets should in general coincide
% with higher expected returns, since investors demand higher
% compensation for the risk involved. As a first application of
% the linear model, we want to investigate whether this positive
% relationship can be verified for German stock data. Therefore,
% we will download historical data of all 30 components of the
% German stock market index DAX, estimate their mean return and 
% return standard deviation, and regress the mean returns on the
% standard deviations. Note that standard deviation is only one
% way to measure inherent risk, and one common criticism is that
% the symmetrical nature of standard deviation measures positive
% deviations the same way as negative ones.

% specify start and end point of investigation period
dateBeg = '01011990';
dateEnd = '01072011';

% download data of all components: dax_comp is structure array
daxComp = {'ADS.DE', 'ALV.DE',...
    'BAS.DE', 'BAYN.DE', 'BEI.DE', 'BMW.DE', 'CBK.DE', 'DAI.DE', ...
    'DB1.DE',...
    'DBK.DE', 'DPW.DE', 'DTE.DE', 'EOAN.DE', 'FME.DE', 'FRE.DE',...
    'HEI.DE', 'HEN3.DE', 'IFX.DE', 'LHA.DE', 'LIN.DE', 'MAN.DE',...
    'MEO.DE', 'MRK.DE', 'MUV2.DE', 'RWE.DE', 'SAP', 'SDF.DE',...
    'SIE.DE', 'TKA.DE', 'VOW3.DE', '^GDAXI'};

%%
% In order to conduct this analysis, we will first use our implemented
% function getPrices to download prices of all DAX components. Afterwards,
% we need to translate the prices into logarithmic returns.

daxCompPrices = getPrices(dateBeg, dateEnd, daxComp);
daxCompRets = price2retWithHolidays(daxCompPrices);

%% 
% Now that we have downloaded the data, we want to visually check them for
% inconsistencies. Therefore, it is best to look at normalized prices:
% we artificially make the starting price for all assets the same. This in
% general could easily be done with function cumsum. However, due to the
% missing observations in our data sample we need to take a different
% function in order to not return NaNs. Here, we use function nancumsum
% from the MATLAB file exchange.

close   % close last figure
normalizedPrices = nancumsum(daxCompRets{:,:});
plot(numDates(daxCompRets), normalizedPrices)
datetick 'x'

%%
% Next, we will calculate the number of observations for each stock. This
% way, we can see whether individual stocks have substantially less data
% than the rest.

nObs = sum(~ismissing(daxCompRets), 1);
nObsTable = array2table(nObs);
nObsTable.Properties.VariableNames = daxCompRets.Properties.VariableNames;

%%
% Now that historical returns are given suitable form, we can
% estimate expected returns and standard deviations. Note
% that most statistical functions act columnwise. Hence it is
% always preferable to store observations of a given variable in
% a column vector, and use different columns for different
% variables. In our case, however, there are NaNs in our columns, which
% will lead to NaNs for any calculations as well. Hence, we need to take
% the missing values into account at each step. For simple statistics like
% mean and variance we can take the respective function from the statistics
% toolbox (nanmean, nanstd, ...).

% estimate returns and sigmas of DAX components
expRets = nanmean(daxCompRets{:,:}*100);
sigmaHats = nanstd(daxCompRets{:,:}*100);

% show in figure, standard deviations on x-axis
close   % close last figure
scatter(sigmaHats, expRets, '.')

% highlight DAX itself
hold on;
scatter(sigmaHats(end), expRets(end), 30, [1 0 0], 'filled')

% estimate regression line
% betaHat = [ones(numel(sigmaHats), 1) sigmaHats']\expRets';
betaHat = [sigmaHats']\expRets';

% calculate regression line
xLimits = get(gca, 'XLim');
grid = linspace(xLimits(1), xLimits(end), 200);   % divide 
                                    % specified interval in 200
                                    % parts of equal size
yVals = [grid']*betaHat;

% include regression line in red
plot(grid, yVals, 'r')

% get R^2 from existing MATLAB function
stats = regstats(expRets, sigmaHats',...
    'linear', 'rsquare');
title(['R-square of regression: ' num2str(stats.rsquare)])
xlabel('estimated standard deviations')
ylabel('estimated mean returns')

%% 
% Although the regression line exhibits an increasing slope as
% theory suggests, the R-squared of the regression is rather
% small. Evidence for a positive relation between return and 
% risk is rather weak.

%% CAPM
% The capital asset pricing model tries to explain asset pricies.
% It is set up on the assumption, that investors only get
% compensated for that part of an asset's risk that can not get
% diversified away in a portfolio. 
% Shortly speaking, each assets partly exhibits comovements with
% the market, called systematic risk. Since this risk component
% underlies each asset, it can not be diversified away. Hence,
% investors need to be compensated for it.
% In contrast to that, the remaining risk inherent in an asset is
% called the idiosyncratic risk. This component is stock
% specific, and hence not correlated with idiosyncratic
% components of other firms. Hence, in a large portfolio of
% assets, this component could be diversified away.

%%
% In order to measure each assets' comovement with the market, we
% perform a linear regression of the daily returns on daily
% returns of a market index. Note that the theory is based on
% dependence to a market portfolio, where our market index here 
% is only an imperfect substitution.

% preallocate vector for estimated betas
nDaxComponents = size(daxCompRets, 2) -1;
betas = zeros(1, nDaxComponents);
for ii=1:nDaxComponents
    betas(ii) = regress(daxCompRets{:, end},...
        daxCompRets{:, ii});   % no intercept involved
end

% plot betas with expected returns
close
scatter(betas, expRets(1:end-1), '.')

% estimate regression coefficients with intercept 
betaHat = [ones(numel(betas), 1) betas']\expRets(1:end-1)';

% include regression line
xLimits = get(gca, 'XLim');
grid = linspace(xLimits(1), xLimits(end), 200);
yVals = [ones(numel(grid), 1) grid']*betaHat;

hold on;
plot(grid, yVals, 'r')
xlabel('estimated beta coefficients')
ylabel('estimated mean returns')
title('CAPM disproved?')

%%
% Note that this analysis is only a very rough investigation of
% the validity of the CAPM, with many sources of error involved
% (only substitute for market portfolio, applied to returns
% instead of excess returns,...). In fact, the purpose merely was
% to come up with some easy example of regression analysis in
% finance. So do not make the mistake to interpret the
% investigations as scientifically rigurous and adequate
% approach. As part of a more thorough investigation at least 
% also returns of larger time horizons would have to be examined.







##### SOURCE END #####
--></body></html>